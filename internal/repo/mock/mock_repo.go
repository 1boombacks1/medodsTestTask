// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"d0c/TestTaskBackDev/internal/models"
	"d0c/TestTaskBackDev/internal/repo"
	"sync"
)

// Ensure, that SessionMock does implement repo.Session.
// If this is not the case, regenerate this file with moq.
var _ repo.Session = &SessionMock{}

// SessionMock is a mock implementation of repo.Session.
//
//	func TestSomethingThatUsesSession(t *testing.T) {
//
//		// make and configure a mocked repo.Session
//		mockedSession := &SessionMock{
//			CreateSessionFunc: func(ctx context.Context, session *models.Session) (string, error) {
//				panic("mock out the CreateSession method")
//			},
//			DropSessionFunc: func(ctx context.Context, session *models.Session) error {
//				panic("mock out the DropSession method")
//			},
//			GetSessionByRefreshTokenFunc: func(ctx context.Context, refreshToken string) (*models.Session, error) {
//				panic("mock out the GetSessionByRefreshToken method")
//			},
//		}
//
//		// use mockedSession in code that requires repo.Session
//		// and then make assertions.
//
//	}
type SessionMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, session *models.Session) (string, error)

	// DropSessionFunc mocks the DropSession method.
	DropSessionFunc func(ctx context.Context, session *models.Session) error

	// GetSessionByRefreshTokenFunc mocks the GetSessionByRefreshToken method.
	GetSessionByRefreshTokenFunc func(ctx context.Context, refreshToken string) (*models.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Session is the session argument value.
			Session *models.Session
		}
		// DropSession holds details about calls to the DropSession method.
		DropSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Session is the session argument value.
			Session *models.Session
		}
		// GetSessionByRefreshToken holds details about calls to the GetSessionByRefreshToken method.
		GetSessionByRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RefreshToken is the refreshToken argument value.
			RefreshToken string
		}
	}
	lockCreateSession            sync.RWMutex
	lockDropSession              sync.RWMutex
	lockGetSessionByRefreshToken sync.RWMutex
}

// CreateSession calls CreateSessionFunc.
func (mock *SessionMock) CreateSession(ctx context.Context, session *models.Session) (string, error) {
	if mock.CreateSessionFunc == nil {
		panic("SessionMock.CreateSessionFunc: method is nil but Session.CreateSession was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Session *models.Session
	}{
		Ctx:     ctx,
		Session: session,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(ctx, session)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedSession.CreateSessionCalls())
func (mock *SessionMock) CreateSessionCalls() []struct {
	Ctx     context.Context
	Session *models.Session
} {
	var calls []struct {
		Ctx     context.Context
		Session *models.Session
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// DropSession calls DropSessionFunc.
func (mock *SessionMock) DropSession(ctx context.Context, session *models.Session) error {
	if mock.DropSessionFunc == nil {
		panic("SessionMock.DropSessionFunc: method is nil but Session.DropSession was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Session *models.Session
	}{
		Ctx:     ctx,
		Session: session,
	}
	mock.lockDropSession.Lock()
	mock.calls.DropSession = append(mock.calls.DropSession, callInfo)
	mock.lockDropSession.Unlock()
	return mock.DropSessionFunc(ctx, session)
}

// DropSessionCalls gets all the calls that were made to DropSession.
// Check the length with:
//
//	len(mockedSession.DropSessionCalls())
func (mock *SessionMock) DropSessionCalls() []struct {
	Ctx     context.Context
	Session *models.Session
} {
	var calls []struct {
		Ctx     context.Context
		Session *models.Session
	}
	mock.lockDropSession.RLock()
	calls = mock.calls.DropSession
	mock.lockDropSession.RUnlock()
	return calls
}

// GetSessionByRefreshToken calls GetSessionByRefreshTokenFunc.
func (mock *SessionMock) GetSessionByRefreshToken(ctx context.Context, refreshToken string) (*models.Session, error) {
	if mock.GetSessionByRefreshTokenFunc == nil {
		panic("SessionMock.GetSessionByRefreshTokenFunc: method is nil but Session.GetSessionByRefreshToken was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		RefreshToken string
	}{
		Ctx:          ctx,
		RefreshToken: refreshToken,
	}
	mock.lockGetSessionByRefreshToken.Lock()
	mock.calls.GetSessionByRefreshToken = append(mock.calls.GetSessionByRefreshToken, callInfo)
	mock.lockGetSessionByRefreshToken.Unlock()
	return mock.GetSessionByRefreshTokenFunc(ctx, refreshToken)
}

// GetSessionByRefreshTokenCalls gets all the calls that were made to GetSessionByRefreshToken.
// Check the length with:
//
//	len(mockedSession.GetSessionByRefreshTokenCalls())
func (mock *SessionMock) GetSessionByRefreshTokenCalls() []struct {
	Ctx          context.Context
	RefreshToken string
} {
	var calls []struct {
		Ctx          context.Context
		RefreshToken string
	}
	mock.lockGetSessionByRefreshToken.RLock()
	calls = mock.calls.GetSessionByRefreshToken
	mock.lockGetSessionByRefreshToken.RUnlock()
	return calls
}
